# MySQL优化和索引

## 如何使用索引

索引类型如下：PRIMARY KEY，UNIQUE，INDEX，FULLTEXT

都是通过B树来实现索引的。spatial数据类型使用R树，MEMORY表也支持hash索引，InnoDB对FULLTEXT索引使用反向链表。

在如下操作时会使用索引：

* 在where语句中迅速匹配行
* 减少搜索范围。如果需要在多个索引中选择，MySQL会使用能够匹配最小行数的索引。
* 如果表有多行配置了索引，索引的最左边前缀会被用于优化查找。
* 当在多个表中进行join操作时，如果索引的类型和大小都一致，则查询更有效率。在非二进制的字符行之间对比，则也需要使用一样的字符集。否则不会使用索引来查询。
* 当在索引行中使用MIN()和MAX()时，预处理器会检查是否在key_col列之前是否有WHERE key_part_N = constant条件。此时，MySQL对每个MIN()和MAX()表达式使用单个键查找，并且会将其替换成常量。如果所有的表达式被替换成常量，则查询会立即返回。
* sort或者group时

索引在表格较小时没有明显作用，对大表格中要获取大多数记录的场景下也没明显作用。当要访问大多数的记录行时，按序依次读访问要比使用索引更快。按序读取会最小化磁盘的搜索。

## 使用Primary Key

主键用于对查询至关重要的列或者列集合中。NOT NULL也会对查询性能有益。在InnoDB存储引擎涨，数据表会在物理上就被存储成特别适用于主键的查找方式。

如果你的表格很大并且也很重要，但是却么有一个行或者一系列行适合用作主键，你可以创建一个独立的行并且赋予自增属性来作为主键。这些唯一的ID可以外键来指向其他表格。

## 使用Foreign Key

如果表格有多个列，需要通过多个列的不同组合来查找，则可以将哪些最少使用的数据单独放到一个表中，并且通过ID列来将他们关联到主表中。

通过join操作可以迅速查找出数据列。

依据数据的不同分布，查询可能会执行更少的I/O操作并且会消耗更少的内存缓存，因为相关的列一起打包到了磁盘上。

## 列索引

大多数的索引类型都是只涉及一个列。

B树适用于=、>、≤、BETWEEN、IN等操作符。

每个表中最大的索引个数和索引最大的长度在每个存储引起中都不一样。所有的存储引擎基本最少吃吃每个表16个索引以及所有的索引长度至少为256字节。大多数存储引擎限制更小。

### 前缀索引

col_name(N)可以创建一个仅使用列的前N个字符的索引。

例如，

```
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
```

索引可以至多有1000字节长度（对InnoDB表为767字节，除非设置inndb_large_prefix)

### FULLTEXT索引

用于全文搜索。只有InnoDB和MyISAM存储引擎支持全文索引，而且只针对CHAR, VARCHAR, TEXT列有效。

### 空间索引

### 内存存储引擎

默认使用HASH索引

## 多列索引

MySQL可以创建组合索引。一个索引最多可以包含16列。

可以加速查询索引的第一列、前两列，前三列作为查询条件的检索。如果在创建表的时候的索引定义中指定了正确序列的列，则一个组合索引可以加速多种查询方式。

例如：
```
CREATE TABLE test {
	id	INT NOT NULL,
	last_name CHAR(30) NOT NULL,
	first_name CHAR(30) NOT NULL,
	PRIMARY KEY (id),
	INDEX name (last_name, first_name)
};
```
可以适用于查询条件为last\_name，以及first\_name的查询，也可以适用于，查询条件为last\_name的查询，因为这是索引的坐左边的列。

但是不适用于查询条件为first_name的查询。

例如：

```
SELECT * FROM tbl_name
	WHERE col1=val1 AND col2=val2;
```

如果col1及col2满足组合索引，则会直接获取相关的数据记录。

如果col1和col2分别创建了索引，则优化器会尝试合并优化，或者尝试去使用限制更严格的而索引。

## 检查索引使用

索引是有开销的，所以只有确认要使用索引时才去创建。

## InnoDB以及MyISAM索引统计




## B树和哈希索引对比

B树适用于=，>, >=，<, <=或者BETWEEN操作符。也适用于LIKE，此时对比的对象必须是字符常量，而且开头不是通配符。多行索引的并行使用必须是AND而不是OR。

哈希索引适用于=以及<=>，不适用于比较运算符。无法加速ORDER BY操作。无法很快确定两个值之间有多少条记录。索引必须要全量使用。