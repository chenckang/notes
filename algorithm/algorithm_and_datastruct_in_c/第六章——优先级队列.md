# 优先级队列(堆)

可以选取数据中最小或者最大值的数据结构，例如用于操作系统的任务优先级调度。

需要支持的操作包含DeleteMin、Insert，可以看做是Enqueue、Dequeue。最简单的实现是借助于二叉查找树，但是如果不断的删除最小值，则查找树的平衡会丢失，导致右子树过重，如果使用AVL树则可以避免最坏的情况。

但是二叉树的操作毕竟包含很多不需要的操作，例如排序这样的属性，以及使用了指针。

## 二叉堆

堆是一个被完全填满的二叉树，其最底层是从左到右依次填满。这样的树称作完全二叉树。

因为完全二叉树很有规律，所以无需使用指针，可以直接使用一个数组表示即可。

具体特征：在数组中，对于未知i上的元素，其做儿子位于2i上，右儿子位于2i+1上，反之可以推算一个元素的父节点。

由于未使用指针，而是简单的使用数组和数组索引，所以在大多数的计算机上这种运算会非常快。

二叉堆支持的操作：

* Insert
* DeleteMin
* DecreaseKey，降低某个位置处的元素值，由于这会破坏堆的特性，需要对堆进行调整。
* IncreaseKey，同上
* Delete，可以通过DecreaseKey和DeleteMin操作来完成
* BuildHeap，N次Insert操作来完成；对已经存在的一个数组，可以使用从N/2起，依次对N/2到1直接的节点做下滤处理，构造出堆的特性。包含2^(h-1) - 1个节点的堆的BuildHeap的最大操作次数为2^(h+1) - 1 - (h + 1)，因而BuildHeap的操作次数是线性的。

二叉堆和二叉查找树不同的一点就是，二叉堆中不含有完整的排序信息。

## 优先级队列的使用

### 选择问题，选择N个元素中的第k小的元素

可以有的解法，将数据按以小到大排序，那么第k个元素既是要选取的元素。
另一种解法，选取数据中的前k个元素，按从小到大排序，从k+1位元素开始，后面的元素一次对比，如果比该元素小，将改元素放到已排序的合适的地方

以上这两种解法的性能都不够好，全排序算法的复杂度至少为O(NlogN)，如果是简单排序则为O(N^2)。第二种解法，为O(Nk)，如果k = N/2，则复杂度为O(N^2)。

使用堆来实现，则是先进行BuildHeap操作，再进行k此DeleteMin操作，由于BuildHeap的复杂度是线性的，k次DeleteMin操作的复杂度为O(klogN)，则总耗时为O(N + klogN)，所以总的最坏复杂度为O(NlogN)。

### 模拟事件

银行排队过程中k个出纳员和C个客户的场景，客户的属性包含到达时间和离开时间，如果要模拟这种场景，则一种方案就是通过实际的时间值来模拟整个事件，这样系统的运行时间就依赖于如何去模拟时间的问题，而不是问题本身的规模。

此时可以按客户的达到时间来构建一个客户输入流，并依据客户的离开时间构建大小为k的优先级队列，每次弹出要离开的客户，并插入下一个排队的客户。这样模拟算法的运行复杂度为O(Clog（k+1))，也就是C个客户每个客户执行的堆操作的时间为log(k+1)，这样就构建了一个高效的模拟方法。

优先级队列特别适用于排队相关的问题；如果只需要非常简单的排序信息，注入获取第k小的元素时也很适用。

## d-堆

堆中所有的节点都有d个儿子，d-堆要比二叉堆浅很多。

如果d值比较大，则DeleteMin操作会耗时很多，如果某种操作插入数据的次数比DeleteMin多很多，则d-堆在理论上也具备较好的执行速度。

堆的问题不支持Find操作，同时将两个堆合并成一个也非常困难。

## 左式堆

用于高效的进行merge操作。

零路径长度——NPL，从X到一个没有两个儿子的节点的最短距离。

左式堆：堆中左儿子的零路径长度至少和右儿子一样大。

## 斜堆

## 二项队列
