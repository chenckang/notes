# 散列

散列只支持一部分树的操作，散列的含义是：以常数的平均时间进行插入、删除以及查找技术，但是并不支持元素之前的任何排序信息的操作。

所以FindMin、FindMax以及元素排序都不是散列所不支持的。

## 基本概念

将元素映射到表的不同位置，而且要解决位置冲突问题。

### 散列函数

散列函数的选取是依赖于输入的，一般输入的内容是字符串，散列函数可以依次遍历字符串并对ASCII码进行求和运算。
另一案例是，h = h * 27 + c，其中27代表26个英文字母加上空格。

## 分离链接发

使用链表的方式来解决冲突的问题。

分裂链接发的查找次数取决于填装因子，也就是元素的个数和表的大小的比值。

如果填装因子为r，则平均失败查找的平均遍历链接的个数为r（不包括最后的NULL），成功查找的平均遍历的链接个数为1+r/2。

所以填装因子决定散列表的性能。一般让表的填装因子接近1，则空间和性能开销相对平衡。

## 开放寻址法

分离链接法的一个问题就是需要给新元素分配内存空间，这相对来说不是很理想。开发寻址法则在一个大小固定的表中分配各个元素，如果有冲突则尝试冲突地址后面的位置，直到找到一个可用位置来存储元素。

表达式：H(i, X) = (Hash(X) + F(i)) (mod TableSize)，其中F为冲突解决函数。

对于开放寻址法中，填装因子r要小于0.5，否则会出现插入失败或者性能下降的问题。

### 线性探测法

F(i) = i，为线性函数。则依次尝试冲突位置的后续位置，直到找到一个可用的位置。

一般来讲，这种方式可能会出现很多连续的位置被占用，为一次聚集，而此时表中可能存在很多其他的空间。

当表几乎要被填满时，性能将会变得极差，通过数学手段分析可得出，当填装因子为0.5时，每次查找遍历的次数可接受。

### 平凡探测法

F(i) = i^2，为平方函数。此时如果填装因子大于0.5时，就无法保证每次插入必然会成功。

开发寻址法中不能进行完全删除操作，否则会导致查找错误错误的结束，可以使用懒删除来完成删除标记。

虽然平凡探测法可以避免一次聚集，但是由于冲突的位置后续的备选位置都遵循同样的过滤，所以仍然会导致二次聚集。

### 双散列

F(i) = i * Hash(X)，此时Hash(X)的值一定不能为0，否则会导致死循环问题。对比与平凡探测法，双散列在理论上很有优势，但是又去其使用了两个散列函数（Hash(X)），在实际运用过程中会稍慢。

## 再散列

如果表太满，则操作时间可能会变得很长，且Insert操作可能失败，此时可以在创建一个两倍大小的散列表，并将原散列表中的元素重新散列到新表中。

这种方式很显然浪费性能，但是由于实际不是经常发生，实际效果其实没这么夸张。如果其作为交互系统的一部分，则命中再散列的用户可能会感觉到系统变慢。

再散列的触发可以是：1）当填满一半时，2）当插入失败时，3）当达到某个填装因子时

## 可扩展散列

类似于B树的，树叶为各个散列表，如果树叶满了，则相应的根部分裂成两个并指向响应的叶子节点散列表。
