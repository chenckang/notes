## 二叉树
## 二叉查找树
关键特征，左子树的所有关键字小于X，右子树的关键字大于X。

由于树的递归定义，通常递归的编写这些操作的例程。因为二叉查找树的平均深度为O(logN)，所以不必担心栈空间被耗尽。

### 主要操作

* MakeEmpty

> 初始化

* Find
* FindMin
* FindMax
* Insert
* Delete

Delete操作比较复杂：如果节点为叶子节点则可以立即删除；如果节点有一个儿子，则在该节点的父节点指向该节点的儿子节点后被释放；如果节点有两个儿子，一般是用其右子树的最小节点代替该节点，并递归的删除该节点，并且右子树的最小节点不可能有子儿子，则第二次删除要容易的多。

删除操作效率并不高，因为每次删除可能要沿着树寻找和删除右子树的最小节点。

如果删除次数不多，则会使用懒删除：当一个元素被删除时，仍然保留在树中，只是被标记成已删除。原因在于，实际节点数于被删除的节点数相等时，树的深度只增加1，对性能消耗非常少。再者如果被删除的节点再次插入到树种则不用新建一个单元。


除了MakeEmpty外，其他的所有操作的开销都是O(d)，其中d为树的深度。
一棵树的所有节点的深度之和为内部路径长。

## 平衡查找树（AVL树)

就是带有平衡条件的二叉查找树，必须保证树的深度为O(log N)。最简单的想法是要求左右子树的高度相同。

但是树的大小并不一定是2^d - 1，所以需要放宽条件。

AVL树的左右子树的高度差最多差1。

高度为h的AVL树种，最小节点树为s(h) = s(h-1) + s(h-2) + 1给出，也就是根节点的左子树的高度为h-1，右子树的高度为h-2。对于h=0，s(h) = 1;h=1, s(h)=2，可以看出这和斐波那契数密切相关，从而能可以推测出AVL树的高度的界。

除了插入外（假设使用懒删除），所有的树的操作为O(logN)。插入操作的困难在于插入一个节点可能会破坏AVL树的特性。实际上通过简单的修正可以来保持AVL树，这个过程称为旋转。

不平衡的可能性：

1. a的左儿子的左子树进行一次插入
2. a的左儿子的右子树进行一次插入
3. a的右儿子的左子树进行一次插入
4. a的右儿子的右子树进行一次插入

1和4是镜像对称的，2和3是镜像对称的。

所以如果插入发生在1和2上，则对树进行一次单旋转；如果发生在2和3上，则对树进行一次双旋转。

### 单旋转

针对1，4可使用单螺旋来解决不平衡问题。

### 双旋转

针对2，3可使用双螺旋来解决不平衡问题，双螺旋使用两次对称的单螺旋完成。

## 伸展树

保证从空树开始连续M次的操作最多花费(MlogN)，但某一次操作可能是O(N)时间。

伸展树的一个基本想法就是，当一个节点被访问后，它就要经过一系列AVL的旋转操作，将其移动到根上。

如果一个节点过深，则其路径上的一些节点也会过深，对齐进行旋转重新构造会增加树的平衡性。

除了在理论上有较好的应用外，在实际中也有使用，例如当一个节点被访问后，其不久很有可能再次被访问到（缓存？）。另外就是伸展树不留高度或者平衡信息，所以会节省空间的大小。

### 展开
