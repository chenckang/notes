# TCP/IP

TCP提供了一种可靠的、有序的比特传输管道。

TCP分组又通过IP分组的小数据块进行传输。

HTTP位于TCP/IP协议栈中的最顶层，是应用层的一个具体应用。

每个IP分组中包含：

* IP分组首部
* IP数据
    * TCP分组首部
    * TCP数据

IP首部包含源IP、目的IP、长度及其他一些标记。
TCP首部包含端口号、控制标记、数据排序及完整性标记。

一个TCP链接通过四个值来识别：

    <源IP，源端口，目的IP，目的端口>

## TCP的性能

### HTTP时延

HTTP时延主要是由TCP时延所引起的，除非客户端和服务器端对HTTP的处理出现故障。

HTTP时延的具体原因：

* DNS解析时延
* TCP连接建立过程中的三次握手时延
* HTTP报文的传输时延，含传输请求报文及响应报文的时延
* 服务器端及客户端处理报文的时延，一般情况下可忽略不计

### TCP本身的时延

三次握手时延，其连接过程如下：

* 客户端发送一个含SYN标记的连接请求
* 服务器接收连接请求，并返回含SYN和ACK的响应请求
* 客户端接受响应请求，校验SYN和ACK，并确认连接建立

### 延迟确认

每个TCP分组都有一个序列号及数据完整性校验和。每段分组被接受后都会向发送者发送已接受的确认分组，发送者如果在一段时间内没有接收到确认分组则会认定数据已丢失，则重发数据。

由于确认分组的报文很小，在TCP向回发送数据时，可以进行捎带，所以很多TCP实现都存在一种“延迟确认”算法，在一个时间段内，将确认分组放在缓存区内，以等待可能的捎带分组一起发送。但延迟算法会极大的增大时延，所以应该依据不同的使用场景来启动或禁止时延算法。

### TCP慢启动

TCP连接会随着时间进行自我调节。具体而言，起初会限制最大的传输速度，随着时间的推进，在发送数据成功的情况下，会逐步提高传输速度。这样会呆滞新建立的连接的传输速度慢于已有的连接速度。

### Nagle算法

如果发送大量包含少量数据的分组，同时每个TCP分组至少装载了40字节的首部数据，则会造成巨大的浪费。Nagle算法将这些小数据合并成一个大数据，并通过一个TCP分组发出去，从而提升传输性能。但存在的问题在于，可能HTTP报文永远无法填满一个TCP分组，且确认分组本身在延迟算法下会延迟100-200ms，又被阻止放送。因而引起了性能问题。

使用TCP_NODELAY配置来禁用Nagle算法，但需自己确保每个TCP写入数据都足够多。

### TIME_WAIT累计

服务器会维护一个小的控制块来记录最近关闭的连接的IP地址及端口号，以确保不会2MSL时间内不会创建同样相同的连接。一旦开启了TIME_WAIT来限制了连接建立，由于服务器端的IP和端口号是确定的， 客户端的IP也是确定的，那么只能使用客户端的不同端口来尝试在TIME_WAIT内多次建立连接，客户端的端口号最大为60000个，因而也就限制了连接的建立频率。

## HTTP连接

### Connection首部

Connection的三种值：

* 首部列表，表明和本次连接关联的首部
* 任意标签，此次连接的非标准选项
* close，操作完成后关闭连接

例如：

    HTTP/1.1 200 OK
    Cache-Control: max-age=3000
    Connection: meter, close
    Meter: max-users=3

表明，不应该转发meter首部，且请求完成后关闭连接。

### 串行连接

串行连接会导致时延的叠加，从而降低整体加载速度，其解决方案有：

* 并行连接
* 持久连接
* 

### 并行连接

并行连接也存在问题

* 在带宽较小的情况下，会耗尽带宽资源，从而实际上并未加快请求
* 大量并发连接会耗尽客户端内存，以及服务器面对大量的并发请求维持大量的连接，从而造成性能问题

浏览器一般限制并发连接数为4个以内

### 持久连接

HTTP/1.1（1.0的增强版）允许在事务处理结束后，将TCP连接保持打开状态，在事务处理结束后仍然保持打开的连接成为持久连接。好处在于，避免了连接重复建立产生的时延，以及TCP慢启动特性造成的阻塞。

Keep-Alive及首部

响应报文中返回`Connection: Keep-Alive`，则客户端在支持的情况下会保持TCP的打开状态，

Keep-Alive首部（仅在`Connection: Keep-Alive`下有效），其值含如下：

* timeout，服务器希望连接维持的时间
* max，服务器希望连接维持的最大数量
* 其他值

在存在代理的持久连接中，代理必须遵守Connection首部的规则，也就是将请求转发之前，删除所有Connection中指定的首部，以及Connection自身。

一个不识别Connection首部的中继代理，在完成转发后会等待连接的关闭，单由于Connection被转发的缘故，客户端和服务器端都认为连接处于打开状态，继续发送后，代理则忽略后续的发送，导致请求一直被挂起，直到超时关闭。

针对盲中继的代理，使用Proxy-Connection来实现持久连接：

如果代理是盲中继，则直接将Proxy-Connection首部转发给服务器端，服务器端直接忽略Proxy-Connection首部。

如果，代理识别Proxy-Connection首部，则将其转换为自己的Connection首部，来实现持久连接。

但针对多重代理，Proxy-Connection也无法解决问题。

HTTP/1.1 则默认打开持久连接，除非发送`Connection: close`首部。

### 管道化连接

持久连接中，借助于这条持久连接，多条请求发送和响应必须串行执行，也就产生了一定的时延（与并发请求不同，此处仅使用一个持久连接来发送处理多条请求）。

因而要求：

* 管道化连接必须建立在持久连接之上
* 请求的顺序和响应的数据必须一致
* 任意时刻请求关闭后，在关闭时还未接收到响应的请求需要再次发送。
* POST类非幂等请求不应该时运管道化请求，由于其不能进行重试。



