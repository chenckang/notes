# 缓存

## 缓存的作用

* 减少冗余数据传输
* 降低客户端等设备的带宽瓶颈
* 减少瞬间网络拥塞的影响
* 减少距离传输时延

## 缓存的访问状态

* 缓存命中
* 缓存未命中
* 缓存再验证

其中，再验证命中，则服务期返回304响应；再验证未命中，且请求对象不满足条件请求的缓存设定（If Modified Since），则返回完整的对象；在验证命中，且请求对象已被删除，则返回404，缓存容易清除缓存副本。

命中率描述主要有文档命中率和字节命中率。文档命中率解释了HTTP事务的节省状态，可以代表时延的减少状况；字节命中率解释了带宽的节省状况。

## 缓存的处理步骤

* 接受请求报文
* 解析请求报文并提取URL和首部，可将响应的信息存放在易于操作的数据结构中
* 查询本地缓存，如果没有就从服务器获取一份或者返回错误信息，缓存中存储了原始响应头部以及用于记录缓存信息的元数据（例如缓存生效的时间长度等）
* 新鲜度检测，超过了新鲜度检测的时间值后，缓存代理会向服务器询问缓存副本是否过期
* 创建响应，缓存代理会对原始报文进行修改和扩充，例如协议版本转换，cache-control、age等信息扩充
* 发送响应
* 日志，记录缓存的命中状况及网络请求的相关信息

## 缓存副本新鲜度

HTTP协议通过文档过期以及服务器再验证来确保缓存的新鲜度。

### 文档过期

HTTP/1.1中通过Cache-Control的相对时间（max-age|秒）来标明文档的过期时间，而在HTTP/1.0中则通过expires的绝对时间值来标明文档的过期时间。

在文档的有效期内，缓存可以任意次被使用而不需要向服务器询问文档的新鲜度。

### 再验证

再验证并不是意味着需要从服务器重新拉去资源，而是意味着核对副本的新鲜度的时间到了。

* 如果服务器资源发生了修改，则将其重新拉取，替换缓存副本，并响应资源请求
* 如果服务器资源为发生修改，则换取缓存头部及一个新过期日期，并更新缓存副本的头部

### 条件请求验证

主要通过If-Modified-Since及If-None-Match进行条件验证。

If-Modified-Since中的时间串是绝对时间，部分服务器则通过将其作为字符串来验证而不是在此日期之后的意思，这样刻意针对时间缓存验证可能会得到意外的结果。

If-None-Match是通过实体标签（ETag)的形式进行比较的，这种方式可以避免时间验证中：

* 周期性的写入文档，但文档内容实际上没有发生变化，只是其修改日期发生了变化
* 有些文档被修改，但是其修改并不重要，不需要通知缓存重新缓存副本
* 部分文档修改时压秒级的，那么精确到秒级的修改时间验证就无法满足条件

例如：
	
	If-None-Match: "v2.6"；
	If-None-Match: "v2.6","v2.7";

## 缓存的控制

HTTP通过几种方式来确定在文档过期之前可以将其缓存多长时间，按优先级递减排序如下：

* Cache-Control: no-store
* Cache-Control: no-cache
* Cache-Control: must-revaidate
* Cache-Control: max-age
* Expires首部
* 不附加信息，让缓存自己确定

### no-store与no-cache

使用格式如下：
	Progma: no-cache
	Cache-Control: no-store
	cache-Control: no-cache

no-store禁止缓存服务器对缓存进行保留，也就是缓存代理会像非缓存代理一样，具体就是将对象返回，并删除对象副本。

no-cache允许缓存服务器保存对象副本，但是在与原始服务器验证新鲜度之前不允许返回缓存副本。也就是缓存生效的前提是必须向服务器进行验证。

Progma首部主要是为了兼容HTTP/1.0服务器

### max-age

意为：缓存代理接受到资源，并且存为本地缓存副本时起，多少秒之后需再向服务器验证其新鲜度。

### Expires首部

类似于max-age，但是指定的是绝对时间，由于服务器的系统可能并不正确，因而并不建议使用这个头部，使用max-age来取代之。

### must-revalidate

意思是在没有事先和服务期进行验证的前提下不能提供这个副本，如果验证新鲜度时原始服务器不可用，则返回504响应。也就是必须严格遵循过期时间限制。

### 试探性缓存设置

针对响应中既没有Cache-Control首部，也没有Expires首部，则可以理由一些算法计算出试探性的使用期。

LM-Factor是这方面的一个常见算法，前提是如果文档中包含最后修改日期。通过估算文档的易变性来设定过期时间。

* 如果最后一次修改发生在很久之前，则可能是一份文档的文档，则可以缓存较长的一段时间
* 如果最后一次修改发生在最近，则可能文档修改的很频繁，那么缓存较短的一段时间

如果，响应中没有最后修改时间，那么没有明确的方法来得到缓存时间，可以设定一个固定值或者设为0来每次出发新鲜度检测。

### 客户端请求缓存指令

max-stale   
max-stale=s 	可以随意提供过期文件，但是如果指定了s，则s秒内无论缓存是否过期都可以返回

min-fresh=s 未来s秒内文档要保持新鲜，也就是请求时如果文档的剩余时间不足s秒则向原始服务器请求或返回错误

max-age=s 	返回缓存时间不超过s秒的文档

Cache-Control: no-cache
Progma: no-cache 		每次必须和服务器再验证后返回缓存资源

Cache-Control: no-store 不得缓存资源，如果已缓存则删除资源

Cache-Control: only-if-cached 只有存在缓存的时候才返回缓存内容



